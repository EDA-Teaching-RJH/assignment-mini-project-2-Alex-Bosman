; collatz conjecture
; if a term is even, the next term is one half of it.
; If a term is odd, the next term is 3 times the previous term plus 1.
; working result is stored in register 15
; test website - https://www.dcode.fr/collatz-conjecture
; some numbers will not work as they cause the ALU to over flow.
; there is no overflow detection in this program.

.define testlabel 23
.register register132 r1
.register r15 rf

; Inital Setup
start:
    mif r15 34; move 34 into gp15 - collatz number to test                       0
    mif register132 1; move 1 into gp1 - for AND mask (even or odd checking)     2
; Beginning
    mfa r1; move AND mask (00000001) into accumulator                            4
    and r15; accumulator = accumulator AND gp15 (masks all bits except 0 bit)    5
;
    bie r1 is_odd; branch to Is Odd if odd, else continue if even                6
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                   6 # bie r(register specified) +3;if true then go to main branching statement, if false go to next line (which will also skip past the main branching statement) - 16 bits
;                   8 # mfa r0; move 0 to accumulator so can indirect branch - 8 bits 
;                   9 # bie r0 +5; branch was false so indirect branch (if r0 == 0 which evaluates to True) to offset where code continues - 16 bits
;                  11  # mif re label(upper 8 bits); load the upper pointer of the label - 16 bits
;                  13  # brh re label(lower 8 bits) - 16 bits
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; since no branch, the number must be even (n/2)
    mfa r15; move gp15 to accumulator                                           15
    lrs; logical right shift accumulator                                        16
    maf r15; move halved result back to gp15                                    17
loop_inf:
    bie r1 loop_inf; branch if equal to 1 (program stop condition)              18
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                   18 # bie r(register specified) +3;if true then go to main branching statement, if false go to next line (which will also skip past the main branching statement) - 16 bits
;                   20 # mfa r0; move 0 to accumulator so can indirect branch - 8 bits 
;                   21 # bie r0 +5; branch was false so indirect branch (if r0 == 0 which evaluates to True) to offset where code continues - 16 bits
;                   23 # mif re label(upper 8 bits); load the upper pointer of the label - 16 bits
;                   25 # brh re label(lower 8 bits) - 16 bits
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


    brh r0 start; goto Beginning                                                27
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                  27 # mif re label(upper 8 bits); load the upper pointer of the label - 16 bits
;                  29 # brh re label(lower 8 bits); branch (with lower 8 bits as immediate) - 16 bits
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Is Odd (3n+1)
is_odd:
    mfa r15; move gp15 to acc                                                   31
    add r15; doubled                                                            32
    add r15; tripled                                                            33
    inc; add 1                                                                  34
    maf r15; move back to gp15                                                  35
    brh r0 start; goto Beginning                                                36
end: ; included so program can handle end labels lol - these will probably just be ignored as nothing is jumping to them
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                 36 # mif re label(upper 8 bits); load the upper pointer of the label - 16 bits
;                 38 # brh re label(lower 8 bits); branch (with lower 8 bits as immediate) - 16 bits
;                 40 lines long program (including 0 line)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;